素晴らしい着眼点です！今回の開発で、巨大な依存関係（MathlibやSciLean）に阻まれてビルドが数十分〜数時間かかるリスクを、**「外科的な個別ビルド」**によって数秒に短縮したテクニックは、まさに「実戦で使えるエンジニアの知恵」です。

これを**「コンパイル最適化・高速化テクニック集」**としてドキュメント化しましょう。

---

# 🚀 ALETHEIA: 高速コンパイル・ビルドテクニック集

プロジェクトが巨大化しても、開発サイクル（Edit-Wait-Test）を停滞させないための戦略。

## 1. 依存関係の「バイパス（外科的）ビルド」

**問題**: `lake build` を使うと、少しの変更でも SciLean や Mathlib 全体の依存関係をスキャンし、`cblas.h` などの外部ライブラリチェックで止まってしまう。
**テクニック**: `lake` を介さず、Lean コンパイラを直接叩いて C コードを生成し、汎用 C コンパイラ（Clang/GCC）で固める。

```bash
# 1. 必要なファイルだけを C に変換 (依存関係のスキャンをスキップ)
lean SimpleOracle.lean -c SimpleOracle.c

# 2. 最小限のリンクで共有ライブラリ化
clang -shared -o libPhysicsOracle.so SimpleOracle.c \
  -I "$LEAN_SYS_PATH/include" \
  -L "$LEAN_SYS_PATH/lib/lean" \
  -l leanshared -fPIC

```

* **効果**: 数十分かかるビルドを **2〜3秒** に短縮。

## 2. インターフェースの「軽量スタブ化」

**問題**: 物理エンジン本体（SciLean等）が未完成、またはビルドエラーの状態でも、Mojo 側の開発を進めたい。
**テクニック**: 重いインポートをすべてコメントアウトした `SimpleOracle.lean` を作成し、型と関数名（ABI）だけを一致させた「軽量ダミー」で開発を先行させる。

* **効果**: 環境構築トラブルとロジック開発を切り離し、**並行開発**を可能にする。

## 3. ABI 安定化による「再コンパイルの極小化」

**問題**: 引数の数や型が変わるたびに、Mojo と Lean の両方を修正・再ビルドするのが面倒。
**テクニック**: 汎用的な **「構造体ポインタ渡し（Structural Passing）」** を採用する。

* **実装**: Lean 側は `(params_ptr : Float)` の1引数に固定し、中身の解釈（オフセット読み出し）だけを Lean 内で変更する。
* **効果**: Mojo 側のシグネチャ（関数定義）を変更せずに、**Lean 側のロジック更新だけで機能追加**が可能になる。

## 4. シンボリックリンク・クリーンアップ

**問題**: `cp` コマンドが古いファイルや壊れたリンクを上書きできず、古いバイナリをテストし続けてしまう「ゾンビ・デバッグ」の発生。
**テクニック**: `rm` による強制削除をビルドスクリプトの先頭に組み込む。

```bash
rm -f ./libPhysicsOracle.so
cp physics_engine/libPhysicsOracle.so ./

```

* **効果**: 「コードを変えたのに結果が変わらない」という**無駄な調査時間をゼロ**にする。

---

### 📝 このドキュメントの意義

これらのテクニックを `OPTIMIZATION.md` として残しておくことで、後からプロジェクトに参加したメンバーが「なぜ `lake` を使わずに `clang` でビルドしているのか？」という意図を即座に理解でき、**「ビルドが遅い」という開発者最大のストレス**から解放されます。

この「高速ビルド基盤」があれば、これからの複雑な SciLean 実装も、サクサク試行錯誤（プロトタイピング）できますね！

次にこの「爆速ビルド環境」を使って、どの部分を強化しましょうか？
