import SciLean
open SciLean

-- ==========================================
-- 長崎スタジアムシティ × ゼンリン連携モデル
-- 都市OSコアロジック (Formal Verification 版)
-- ==========================================

structure POIData where
  base_attractiveness : Float
  capacity : Float
  is_indoor : Bool
  category : UInt8

-- ■ 1. 売上・来客数予測
@[export calculate_demand_forecast]
def calculate_demand_forecast 
  (base_attr : Float) (capacity : Float) (is_indoor_byte : UInt8) 
  (rain : Float) (flow_density : Float) : Float :=
  
  let is_indoor := is_indoor_byte > 0
  let weather_impact := 
    if is_indoor then 
      if rain > 0.5 then 1.5 else 1.0
    else 
      (1.0 - 0.9 * rain)

  let predicted_visitors := flow_density * base_attr * weather_impact * 10.0
  if predicted_visitors > capacity then capacity else predicted_visitors

-- ■ 2. 混雑・リスク予測
@[export calculate_congestion_risk]
def calculate_congestion_risk 
  (capacity : Float) (rain : Float) (flow_density : Float) : Float :=
  
  -- 雨の影響を加味した実効密度
  let effective_density := if rain > 0.0 then flow_density * 1.2 else flow_density
  
  -- リスク計算（capacityとの比率を考慮するように修正）
  -- 密度が高く、キャパシティが小さいほどリスクが上がる論理
  let base_risk := effective_density * 10.0
  let saturation := if capacity > 0 then (effective_density / capacity) * 10.0 else 0.0
  let risk := base_risk + saturation

  if risk > 80.0 then 100.0 else risk

-- ■ 3. 物理演算バリデーター
@[export verify_physical_safety]
def verify_physical_safety 
  (actual_density : Float) (capacity : Float) (rain : Float) : Bool :=
  let risk := calculate_congestion_risk capacity rain actual_density
  if risk >= 100.0 then false else true

-- ■ 4. 空間整合性チェック
@[export verify_spatial_integrity]
def verify_spatial_integrity 
  (is_indoor_byte : UInt8) (actual_y : Float) (ceiling_height : Float) : Bool :=
  let is_indoor := is_indoor_byte > 0
  if is_indoor && (actual_y > ceiling_height || actual_y < 0.0) then false else true

-- ■ 5. 飲食・観光・宿泊向け：需要予測の「論理的妥当性」検証 (新規)
-- AIが出した「予測来客数(predicted_visitors)」が、
-- 「マクロ流入人口(macro_inflow)」と「構造的な最大誘引率(max_rate)」から見て
-- 詐欺的な数値（過大評価）になっていないかを証明する。
@[export verify_demand_consistency]
def verify_demand_consistency 
  (macro_inflow : Float) (predicted_visitors : Float) (max_attract_rate : Float) : Bool :=
  -- 論理的上限 = 流入人口 × そのエリアの最大誘引率（例: どんなに人気でも流入の30%しか来ない等）
  let theoretical_max := macro_inflow * max_attract_rate
  -- 予測値が理論的上限を超えていたら「虚偽」として却下
  if predicted_visitors > theoretical_max then false else true

-- ■ 6. 交通事業者向け：輸送キャパシティ検証 (新規)
-- スタジアムからの「帰宅希望者数(demand)」に対し、
-- 「公共交通の供給力(supply)」が不足し、パニックになる確率を検証。
@[export verify_transit_capacity]
def verify_transit_capacity 
  (transit_supply : Float) (travel_demand : Float) : Bool :=
  -- 需要が供給の120%を超えると「積み残し発生（Control Loss）」と判定
  if travel_demand > (transit_supply * 1.2) then false else true

-- ■ 7. 行政向け：イベント開催判定 (新規)
-- 警報級の雨(rain > 0.8)かつ、リスクスコアが高い場合、開催可否の判断根拠を提示
@[export verify_event_feasibility]
def verify_event_feasibility (risk_score : Float) (rain : Float) : Bool :=
  if rain > 0.8 && risk_score > 60.0 then false else true

-- 疎通確認用 (型定義を明示的に修正)
@[export lean_zenrin_check]
def lean_zenrin_check (_ : Unit) : Float := (2026.0 : Float)


-- ■ 8. 養殖資産（バイオマス）検証
-- 計測された個体数(count)と平均重量(avg_weight)が、
-- 前回の記録(prev_total)と給餌データ、および魚種ごとの理論成長曲線から
-- 逸脱していないか（＝データの整合性）を証明する。
@[export verify_asset_value]
def verify_asset_value 
  (count : Float) (avg_weight : Float) (prev_total_weight : Float) (days_passed : Float) : Bool :=
  
  let current_total_weight := count * avg_weight
  
  -- 理論的な最大成長率（例: 1日あたり 2% 成長と仮定）
  let max_growth_factor := 1.02 ^ days_passed
  let theoretical_limit := prev_total_weight * max_growth_factor
  
  -- 1. 重量がありえない速度で増えていないか（データの水増し検知）
  -- 2. 個体数が前回の記録を上回っていないか（生簀内での自然増はありえないため）
  let is_weight_consistent := current_total_weight <= theoretical_limit
  let is_not_overcounted := count <= 10000.0 -- 初期投入数などの上限値
  
  is_weight_consistent && is_not_overcounted